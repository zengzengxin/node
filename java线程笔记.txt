线程是一个程序的不同执行路径

进程只是一个概念

线程创建有两种方法，从Thread继承和实现ruanable方法，但是ruanable方法更加适合，应为接口可以可多个，还可以继续继承比较方便

sleep 使当前线程睡眠一段时间，但是仍然保留着锁，在睡眠时间结束后自己醒来

join 合并两个线程

yield（）；暂时剥夺线程


synchronized 封锁当前对象和代码段，但是还是可以在别的线程调用 未封锁的代码段 访问 被封锁的代码段中的某个语句，导致数据不一致，注：不论几个线程只能访问一个带synchronized的方法，通过在 企图调用被封锁的代码段的某一条语句的方法 也加锁，可以避免未封锁方法 调用 被锁定的方法的某条语句 导致数据前后不一致，

一般在修改数据的地方加锁，而读取数据不加锁

wait()：当前的正在访问我的这个线程停下休息，只有锁定的方法里才能wait（），需要进行try 和 catch，并且马上中断线程，失去synchronized权，不会自动醒来，而sleep只是睡着了，会自己醒来，不丢失synchronized权

notify（）：叫醒一个正在wait的对象（不是叫醒自己，notify的意思是叫醒全部的wait对象），与wait（）相反，两个成对出现
